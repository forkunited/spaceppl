/*var outputKLTSV = function(results) {
	display("iterations\tsamples\tworldPriorCount\tKL\ttranslatedKL\tscaledKL\trotatedKL\tstdKL\tstdTranslatedKL\tstdScaledKL\tstdRotatedKL");
	return map(function(r) {
		display(r.iterations + "\t" + r.samples + "\t" + r.worldPriorCount + "\t" + r.kls.meanKL + "\t" + r.kls.meanTranslatedKL + "\t" + r.kls.meanScaledKL + "\t" + r.kls.meanRotatedKL + "\t" + r.kls.stdKL + "\t" + r.kls.stdTranslatedKL + "\t" + r.kls.stdScaledKL + "\t" + r.kls.stdRotatedKL );
	}, results);
}*/

var runTrainingExperiment = function(params) {
	/*display("Making world priors...");
	var testWorldPriorsCollection = discretePointWorldUniformPriorCollectionInit(params.worldWidth, params.worldHeight, params.possiblePositionCount, params.pointRefs, false, params.worldPriorCount[worldPriorCount.length-1]); 
	var testWorldPrior = worldPriorsCollection.parameterizedPrior;
	var testWorldPriorParameters = getCanonicalParameters(worldPriorsCollection.parameterClasses);
	var TestWorldPrior = worldPriorsCollection.ParameterizedPrior;
	*/
	return _.flatten(map(function(iterations) {
		return map(function(samples) {
			return map(function(worldPriorCount) {
				var localParams = { rsaDist : params.rsaDist,
									rsaTrainingLevel : params.rsaTrainingLevel,
                                    rsaEvaluationLevel : params.rsaEvaluationLevel,
									alpha : params.alpha,
									trainingSamplesPerUtteranceWorld : samples,  // Want 1000 per utterance (then give 200 here if 5 world priors)
									trainingIterations : iterations,
									trainingGradientSamples : params.trainingGradientSamples,
									pointRefs : params.pointRefs, 
									worldWidth : params.worldWidth,
									worldHeight : params.worldHeight,
									possiblePositionCount : params.possiblePositionCount,
									worldPriorCount : worldPriorCount,
									nearThresholds : params.nearThresholds,
									nearVagueness : params.nearVagueness } 
				
				var trainingResults = runTrainingEpisode(localParams);
				var dists = makeTransformedDistributions(trainingResults, localParams);
				if (params.evaluation == "KL") {
					var kls = computeKLs(dists, trainingResults.utterances, trainingResults.worldPriorParameters);
					return { iterations : iterations, samples : samples, worldPriorCount : worldPriorCount, kls : kls }
				} else if (params.evaluation == "KTD") {
					var ktds = computeKTDs(dists, trainingResults.utterances, trainingResults.worldPriorParameters);
					return { iterations : iterations, samples : samples, worldPriorCount : worldPriorCount, ktds : ktds }
				} else {
					var wktds = computeWKTDs(dists, trainingResults.utterances, trainingResults.worldPriorParameters);
					return { iterations : iterations, samples : samples, worldPriorCount : worldPriorCount, wktds : wktds }
				}
			}, params.worldPriorCount)
		}, params.trainingSamplesPerUtteranceWorld)
	}, params.trainingIterations));
}

var runTrainingEpisode = function(params) { 
	display("Making world priors...");
	var worldPriorsCollection = discretePointWorldUniformPriorCollectionInit(params.worldWidth, params.worldHeight, params.possiblePositionCount, params.pointRefs, false, params.worldPriorCount); 
	var worldPrior = worldPriorsCollection.parameterizedPrior;
	var worldPriorParameters = getCanonicalParameters(worldPriorsCollection.parameterClasses);
	var WorldPrior = worldPriorsCollection.ParameterizedPrior;

	display("Making utterance prior...");
	var utterancePrior = nearFirstRestUtteranceUniformPrior(params.pointRefs);
	var utterances = constructSupport(utterancePrior);
	
	var nearThresholdPrior = function() { uniformDraw(params.nearThresholds) };

	// Hidden size, input size (input is 4 for two 2d points)
	var nearPointsNetworkParametersPrior = function() { return nnGaussianParameterPrior(4,4); } /* First is hidden size */

	var trueDist = makeSpatialRSA(params.rsaDist, params.rsaTrainingLevel, params.alpha, worldPrior, utterancePrior, nearThresholdPrior, params.nearVagueness);

	var trainingResults = trainSpatialRSA(
				params.rsaDist,
				params.rsaTrainingLevel,
				params.alpha,
				worldPrior,
				utterancePrior,
				nearThresholdPrior,
				params.nearVagueness,
				params.trainingIterations,
				params.trainingSamplesPerUtteranceWorld,
				params.trainingGradientSamples,
				nearPointsNetworkParametersPrior,
				worldPriorParameters);

	var trainedDist = trainingResults[0];
	var nearPointsNetworkParameters = trainingResults[1].fixedParameters.nearPointsNetworkParameters;
	
	return { trueDist : trueDist,
		 trainedDist : trainedDist, 
		 nearPointsNetworkParameters : nearPointsNetworkParameters,
		 WorldPrior : WorldPrior,
		 worldPrior : worldPrior,
		 worldPriorParameters : worldPriorParameters,
		 nearThresholdPrior : nearThresholdPrior,
		 utterancePrior : utterancePrior,
		 utterances : utterances
	};
}

var makeTransformedDistributions = function(trainingResults, params) {
	var nearThresholdPrior = trainingResults.nearThresholdPrior;
	var utterancePrior = trainingResults.utterancePrior;
	var nearPointsNetworkParameters = trainingResults.nearPointsNetworkParameters;
	
	var TranslatedWorldPrior = transformParameterizedPrior(function(Prior) { return translateWorldDistribution(Prior,10,10) }, trainingResults.WorldPrior, trainingResults.worldPriorParameters);
	var ScaledWorldPrior = transformParameterizedPrior(function(Prior) { return scaleWorldDistribution(Prior,10,10) }, trainingResults.WorldPrior, trainingResults.worldPriorParameters);
	var RotatedWorldPrior = transformParameterizedPrior(function(Prior) { return rotateWorldDistribution(Prior,3.14/3) }, trainingResults.WorldPrior, trainingResults.worldPriorParameters);
	
	var translatedWorldPrior = function(param) { return sample(TranslatedWorldPrior(param)) };
	var scaledWorldPrior = function(param) { return sample(ScaledWorldPrior(param)) };
	var rotatedWorldPrior = function(param) { return sample(RotatedWorldPrior(param)) };
	
	var translatedRsa = makeSpatialRSA(RSA_All, params.rsaEvaluationLevel, params.alpha, translatedWorldPrior, utterancePrior, nearThresholdPrior, params.nearVagueness);
	var scaledRsa = makeSpatialRSA(RSA_All, params.rsaEvaluationLevel, params.alpha, scaledWorldPrior, utterancePrior, nearThresholdPrior, params.nearVagueness);
	var rotatedRsa = makeSpatialRSA(RSA_All, params.rsaEvaluationLevel, params.alpha, rotatedWorldPrior, utterancePrior, nearThresholdPrior, params.nearVagueness);
	
	var translatedTrainedRsa = makeSpatialRSA(RSA_All, params.rsaEvaluationLevel, params.alpha, translatedWorldPrior, utterancePrior, nearThresholdPrior, params.nearVagueness, nearPointsNetworkParameters);
	var scaledTrainedRsa = makeSpatialRSA(RSA_All, params.rsaEvaluationLevel, params.alpha, scaledWorldPrior, utterancePrior, nearThresholdPrior, params.nearVagueness, nearPointsNetworkParameters);
	var rotatedTrainedRsa = makeSpatialRSA(RSA_All, params.rsaEvaluationLevel, params.alpha, rotatedWorldPrior, utterancePrior, nearThresholdPrior, params.nearVagueness, nearPointsNetworkParameters);

	var trueRsa = makeSpatialRSA(RSA_All, params.rsaEvaluationLevel, params.alpha, trainingResults.worldPrior, utterancePrior, nearThresholdPrior, params.nearVagueness);
	var trainedRsa = makeSpatialRSA(RSA_All, params.rsaEvaluationLevel, params.alpha, trainingResults.worldPrior, utterancePrior, nearThresholdPrior, params.nearVagueness, nearPointsNetworkParameters);

	var defaultWorldsAndParams = constructSupport(trainingResults.worldPrior, trainingResults.worldPriorParameters);
    var translatedWorldsAndParams = constructSupport(translatedWorldPrior, trainingResults.worldPriorParameters);
    var scaledWorldsAndParams = constructSupport(scaledWorldPrior, trainingResults.worldPriorParameters);
    var rotatedWorldsAndParams = constructSupport(rotatedWorldPrior, trainingResults.worldPriorParameters);

	return {
		Default : { gold : trueRsa, trained : trainedRsa, worldsAndParameters : defaultWorldsAndParams },
		Translated : { gold : translatedRsa, trained : translatedTrainedRsa, worldsAndParameters : translatedWorldsAndParams },
		Scaled : { gold : scaledRsa, trained : scaledTrainedRsa, worldsAndParameters : scaledWorldsAndParams },
		Rotated : { gold : rotatedRsa, trained : rotatedTrainedRsa, worldsAndParameters : rotatedWorldsAndParams }
	};
}

var displayDistributions = function(dists, utterance, worldSampleIndex) {
	var displayWorldDist = function(name, Dist) { display(name); display(spaceppl.util.distToArray(pointToDistanceWorldDistribution(Dist, 'p1', 3),3)) };
    var displayDist = function(name, Dist) { display(name); display(spaceppl.util.distToArray(Dist,3)) };

	return mapObject(function(transKey, lds) {
        var world = lds.worldsAndParameters[0][worldSampleIndex];
        var worldPriorParam = lds.worldsAndParameters[1][worldSampleIndex];

		return map2(function(ldGold, ldTrained) {
            var trueL = ldGold.L;
            var trueS = ldGold.S;
            var trainedL = ldTrained.L;
            var trainedS = ldTrained.S;
			var level = ldGold.l;

            displayWorldDist(transKey + " L" + level, trueL(utterance, worldPriorParam));
            displayWorldDist(transKey + " L" + level + " (trained)", trainedL(utterance, worldPriorParam));
            display("Example world:")
            display(summarizePointWorldByDistance(world, 'p1', 3));
            displayDist(transKey + " S" + level, trueS(world, worldPriorParam));
            displayDist(transKey + " S" + level + " (trained)", trainedS(world, worldPriorParam));
		}, lds.gold, lds.trained);
	}, dists);
}

var computeKL = function(trueDist, trainedDist, params0, params1, prod) {
    var mapFn = (prod) ? mapProduct : map2;

	var kls = mapFn(function(param0, param1) {
		var kl = spaceppl.util.KL(trueDist(param0,param1), trainedDist(param0,param1));
		if (0 <= kl)
			return kl;
		else
			return undefined;
	}, params0, params1);

	var filteredKLs = filter(function (item) { item != undefined }, kls);
	
	return [listMean(filteredKLs), listStdev(filteredKLs)];
};

var computeTopAccuracy = function(trueDist, trainedDist, params0, params1, prod) {
    var mapFn = (prod) ? mapProduct : map2;

    var accs = mapFn(function(param0, param1) {
        return spaceppl.util.topMatch(trueDist(param0,param1), trainedDist(param0,param1));
    }, params0, params1);

    var filteredAccs = filter(function (item) { item != undefined }, accs);

    return [listMean(filteredAccs), listStdev(filteredAccs)];
};

/* FIXME Later
var computeKTD = function(trueDist, trainedDist, params0, params1) {
	var ktds = mapProduct(function(param0, param1) {
			return spaceppl.util.kendallTauDistance(trueDist(param0, param1), trainedDist(param0, param1));
	}, params0, params1)

	return [listMean(ktds), listStdev(ktds)];
};

var computeWKTD = function(trueDist, trainedDist, params0, params1) {
	var ktds = mapProduct(function(param0, param1) {
			return spaceppl.util.weightedKendallTauDistance(trueDist(param0, param1), trainedDist(param0, param1));
	}, params0, params1)

	return [listMean(ktds), listStdev(ktds)];
};
*/

var computeKLs = function(dists, utterances, worldPriorParameters) {
    return mapObject(function(transKey, lds) {
        return map2(function(ldGold, ldTrained) {
            var trueL = ldGold.L;
            var trueS = ldGold.S;
            var trainedL = ldTrained.L;
            var trainedS = ldTrained.S;
            var level = ldGold.l;

            var KL_S = computeKL(trueL, trainedL, utterances, worldPriorParameters, true);
            var KL_L = computeKL(trueS, trainedS, lds.worldsAndParameters[0], lds.worldsAndParameters[1], false);

            return { level : level, KL_L : KL_L, KL_S : KL_S };
        }, lds.gold, lds.trained);
    }, dists);
}

var computeTopAccuracies = function(dists, utterances, worldPriorParameters) {
    return mapObject(function(transKey, lds) {
        return map2(function(ldGold, ldTrained) {
            var trueL = ldGold.L;
            var trueS = ldGold.S;
            var trainedL = ldTrained.L;
            var trainedS = ldTrained.S;
            var level = ldGold.l;

            var acc_S = computeTopAccuracy(trueL, trainedL, utterances, worldPriorParameters, true);
            var acc_L = computeTopAccuracy(trueS, trainedS, lds.worldsAndParameters[0], lds.worldsAndParameters[1], false);

            return { level : level, Accuracy_L : acc_L, Accuracy_S : acc_S };
        }, lds.gold, lds.trained);
    }, dists);
}