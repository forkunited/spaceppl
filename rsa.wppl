var RSA_L = 0;
var RSA_L_w = 1;
var RSA_S = 2;
var RSA_L_0 = 3;

var makeRSA = function(params, returnDist) {
	var cacheSize = 10000;

	var memApply = cache(function(utterance, world, parameters) {
			return spaceppl.semantics.apply(utterance, world, parameters);	
		}, cacheSize);

	var utterancePrior = params.utterancePrior;
	var worldPrior = params.worldPrior;
	var parametersPrior = params.parametersPrior;

	var inferParams = { method : 'enumerate' };

	var L_0 = cache(function(utterance, parameters) {
			return Infer(inferParams, function() {
				var world = worldPrior(parameters);
				var truthValue = memApply(utterance, world, parameters);
				factor(Math.log(truthValue));
				return world;
			})
		}, cacheSize);

		
	var S = cache(function(world, parameters) {
			return Infer(inferParams, function() {
				var utterance = utterancePrior(parameters);
				var L_0_up = L_0(utterance, parameters);
				factor(parameters.alpha*L_0_up.score(world));
				return utterance;
			})
		}, cacheSize);


	var L = cache(function(utterance, localParameters) {
			return Infer(inferParams, function() {
				var parameters = parametersPrior(localParameters);
				var world = worldPrior(parameters);
				var S_wp = S(world, parameters);
				factor(S_wp.score(utterance));
				return world; 
			})
		}, cacheSize);


	if (returnDist == RSA_S) {
		return S
	} else if (returnDist == RSA_L_0) {
		return L_0
	} else {
		return L
	}
	
	/*  Note: Can't just return object containing functions here.. because 
         *  webppl screws up function arguments when the functions are properties
         *  of an object
         */
}
