var makeData = function(distribution, samplesPerInput, possibleInputs0, possibleInputs1, allInputPairs) {
	if (possibleInputs1 != undefined && allInputPairs) {
        return _.flatten(
            map(function (input) {
                return map(function (input1) {
                    var dist = distribution(input, input1);
                    return repeat(samplesPerInput, function () {
						/*display(input);
						 display(input1);
						 display(dist);*/
                        return {input: input, input1: input1, output: sample(dist)};
                    });
                }, possibleInputs1);
            }, possibleInputs0),
            false);
    } else if (possibleInputs1 != undefined && !allInputPairs) {
        return _.flatten(
            map2(function(input, input1) {
                    var dist = distribution(input, input1);
                    return repeat(samplesPerInput, function() {
                        return {input: input, input1: input1, output: sample(dist)}
                    });
                },
                possibleInputs0, possibleInputs1),
			/* shallow */ true);
	} else {
		return _.flatten(
			map(function(input) {
				var dist = distribution(input);
				return repeat(samplesPerInput, function() {
					return {input: input, output: sample(dist)}
				});
			}, 
			possibleInputs0), 
			/* shallow */ true);
	}
} 

var makeTrainingObj = function(model, parameterPrior) {
	return function(data) {
		return function() {
			var parameters = parameterPrior();
			var modelInstance = model(parameters);
		
			if (data) {
				mapData({ data: data /*, batchSize : 100 */}, function(datum) {
					var dist = modelInstance(datum.input, datum.input1);
					observe(dist, datum.output);
				});
			}

			return [modelInstance, parameters]; //return modelInstance;
		}
	}
}

var train = function(trainingObj, data, iterations, gradientSamples) {
	var trainingResults = Optimize(trainingObj(data),
			{
				steps: iterations,
				estimator : { ELBO : { samples : gradientSamples }},
			});

	//mapObject(function(k,v) { display(v) }, trainingResults);

	return sample(SampleGuide(trainingObj(), { params: trainingResults }));
}

var makeVector = function(arr) {
	return Tensor([arr.length,1], arr);
}

var nnparam = function (a, b) {
	return param({ dims: [a, b], mu: 0, sigma: 0.1});
};


var sampleMatrixGaussian = function (dims, mean, variance, guide_mean) {
	var length = dims[0] * dims[1]
	var g = sample(DiagCovGaussian({ mu: Vector(repeat(length, constF(mean))), sigma: Vector(repeat(length, constF(variance))) }),
	{ guide: DiagCovGaussian({ mu: T.reshape(guide_mean, [length, 1]), sigma: Vector(repeat(length, constF(0.001))) }) })
	return T.reshape(g, dims)
}

var sampleScalarGaussian = function (mean, variance, name) {
	return sample(Gaussian({ mu: mean, sigma: variance }),
	{ guide: Gaussian({ mu: param({ mu: mean, name: name }), sigma: 0.001 }) });
}

var nnGaussianParameterPrior = function (hiddenSize, inputSize) {
	var W0_var = nnparam(hiddenSize, inputSize)
	var W1_var = nnparam(1, hiddenSize)
	var b0_var = nnparam(hiddenSize, 1)
	var b1_var = nnparam(1, 1)

	var W0 = sampleMatrixGaussian([hiddenSize, inputSize], 0, 10, W0_var)
	var W1 = sampleMatrixGaussian([1, hiddenSize], 0, 10, W1_var)
	var b0 = sampleMatrixGaussian([hiddenSize, 1], 0, 10, b0_var)
	var b1 = sampleMatrixGaussian([1, 1], 0, 10, b1_var)

	return { W: [W0, W1], b: [b0, b1] };
}

//var gaussianNN = function(hiddenSize, inputSize) {
//	var params = nnParameterPrior(hiddenSize, inputSize);
//	var W = params.W;
//	var b = params.b;
//
//	return function(input) {
//		console.log("Input")
//		console.log(input)
//		var inputVector = makeVector(input);
//		var h = T.tanh(T.add(T.dot(W[0], inputVector), b[0]));
//		var output = T.add(T.dot(W[1], h), b[1]);
//		
//		//var inputAsArray = input.toFlatArray();
//		// console.log("height: " + inputAsArray[0] + 
//		//     ", weight: " + inputAsArray[1] +
//		//     ", output: " + T.sumreduce(ad.value(output)));
//		
//		return T.sumreduce(output)
//	};
//};

