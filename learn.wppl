var makeDataInputProduct = function(distribution, samplesPerInput) {
	var args = _.rest(arguments, 2);
	return mapProductArgs(function() {
		var args = arguments;
		var dist = applyFn(distribution, args);
		return repeat(samplesPerInput, function() {
			var input = _.clone(args);
			var output = sample(dist);
			return { input : input, output: output };
		});
	}, args);
};

var makeDataInputTuple = function(distribution, samplesPerInput) {
    var args = _.rest(arguments, 2);
    return mapTupleArgs(function() {
        var args = arguments;
        var dist = applyFn(distribution, args);
        return repeat(samplesPerInput, function() {
            var input = _.clone(args);
            var output = sample(dist);
            return { input : input, output: output };
        });
    }, args);
};

var makeData = function(distribution, samplesPerInput, inputs) {
	return _.flatten(
		map(function(input) {
			var dist = distribution(input);
			return repeat(samplesPerInput, function() {
				return {input: input, output: sample(dist)}
			});
		},
		inputs),
		/* shallow */ true);

};

var makeDataFromFeatureMatrices = function(inputF, outputF, params) {
    var outputD = spaceppl.feature.getFeatureMatrixData(outputF);
	return _.values(mapObject(function(id, inputf) {
		var outputf = outputD[id];
		var inputMat = spaceppl.feature.getFeatureMatrixFromDatum(inputf);
		var outputMat = spaceppl.feature.getFeatureMatrixFromDatum(outputf);

		var inputTensors = spaceppl.matrix.matrixToRowTensorList(inputMat);
		var outputTensorsTemp = spaceppl.matrix.matrixToRowTensorList(outputMat);
        // FIXME Hack for now since tensors in js are different from tensors in wppl?
		var outputTensors = map(function(t) { Vector(t.toFlatArray()) }, outputTensorsTemp);

		return {
			id : id,
			game : spaceppl.feature.getGameFromDatum(outputf),
			input : (params.inputSequence) ? inputTensors : inputTensors[0],
			output : (params.outputSequence) ? outputTensors : outputTensors[0]};
	}, spaceppl.feature.getFeatureMatrixData(inputF)));
};

var splitDataOnKey = function(D, portion, key) {
	var keyValues = _.uniq(map(function(d) { return d[key];  }, D));
    var splitPartKeys = randomSubset(keyValues, Math.floor(portion*keyValues.length), false);
	var splitPartKeysObj = spaceppl.util.makeObject(map(function(k) { return [k, 1]}, splitPartKeys));

    var splitPart0 = filter(function(d) { return _.has(splitPartKeysObj, d[key]) }, D);
    var splitPart1 = filter(function(d) { return !_.has(splitPartKeysObj, d[key]) }, D);

    return [splitPart0, splitPart1];
};

var makeTrainingObj = function(model, parameterPrior, params) {
	return function(data) {
		return function() {
			var parameters = parameterPrior();
			var modelInstance = model(parameters);
		
			if (data) {
				mapData({ data: data, batchSize : params.batchSize}, function(datum) {
					if (params.modelObserves)
						applyFn(modelInstance, _.union(datum.input, datum.output))
					else {
                        var dist = (params.inputSequence) ? modelInstance(datum.input) : applyFn(modelInstance, datum.input);
						/*display(sample(dist));
						display("Out");
						display(datum.output);*/
						//observe(dist, datum.output); FIXME This is how it worked before
                    	//display(datum.output);
                    	//display(dist);
                    	//display(dist.score(Vector([10,10])))
						factor(dist.score(datum.output));
					}
				});
			}

			return [modelInstance, parameters]; //return modelInstance;
		}
	}
}

var train = function(trainingObj, data, iterations, gradientSamples) {
	var trainingResults = Optimize(trainingObj(data),
			{
				steps: iterations,
				estimator : { ELBO : { samples : gradientSamples }},
			});
	return sample(SampleGuide(trainingObj(), { params: trainingResults }));
}

var makeVector = function(arr) {
	return Tensor([arr.length,1], arr);
}

var nnparam = function (a, b) {
	return param({ dims: [a, b], mu: 0, sigma: 0.1});
};

var sampleMatrixGaussian = function (dims, mean, variance, guide_mean) {
	var length = dims[0] * dims[1]
	var g = sample(DiagCovGaussian({ mu: Vector(repeat(length, constF(mean))), sigma: Vector(repeat(length, constF(variance))) }),
	{ guide: DiagCovGaussian({ mu: T.reshape(guide_mean, [length, 1]), sigma: Vector(repeat(length, constF(0.001))) }) })
	return T.reshape(g, dims)
}

var sampleScalarGaussian = function (mean, variance, name) {
	return sample(Gaussian({ mu: mean, sigma: variance }),
	{ guide: Gaussian({ mu: param({ mu: mean, name: name }), sigma: 0.001 }) });
}

var nnGaussianParameterPrior = function (hiddenSize, inputSize) {
	var W0_var = nnparam(hiddenSize, inputSize)
	var W1_var = nnparam(1, hiddenSize)
	var b0_var = nnparam(hiddenSize, 1)
	var b1_var = nnparam(1, 1)

	var W0 = sampleMatrixGaussian([hiddenSize, inputSize], 0, 10, W0_var)
	var W1 = sampleMatrixGaussian([1, hiddenSize], 0, 10, W1_var)
	var b0 = sampleMatrixGaussian([hiddenSize, 1], 0, 10, b0_var)
	var b1 = sampleMatrixGaussian([1, 1], 0, 10, b1_var)

	return { W: [W0, W1], b: [b0, b1] };
}

