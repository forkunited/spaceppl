var makeDataInputProduct = function(distribution, samplesPerInput) {
	var args = _.rest(arguments, 2);
	return mapProductArgs(function() {
		var args = arguments;
		var dist = applyFn(distribution, args);
		return repeat(samplesPerInput, function() {
			var input = _.clone(args);
			var output = sample(dist);
			return { input : input, output: output };
		});
	}, args);
}

var makeDataInputTuple = function(distribution, samplesPerInput) {
    var args = _.rest(arguments, 2);
    return mapTupleArgs(function() {
        var args = arguments;
        var dist = applyFn(distribution, args);
        return repeat(samplesPerInput, function() {
            var input = _.clone(args);
            var output = sample(dist);
            return { input : input, output: output };
        });
    }, args);
}

var makeData = function(distribution, samplesPerInput, inputs) {
	return _.flatten(
		map(function(input) {
			var dist = distribution(input);
			return repeat(samplesPerInput, function() {
				return {input: input, output: sample(dist)}
			});
		},
		possibleInputs0),
		/* shallow */ true);

} 

var makeTrainingObj = function(model, parameterPrior, batchSize) {
	return function(data) {
		return function() {
			var parameters = parameterPrior();
			var modelInstance = model(parameters);
		
			if (data) {
				mapData({ data: data, batchSize : batchSize}, function(datum) {
					var dist = applyFn(modelInstance, datum.input);
					observe(dist, datum.output);
				});
			}

			return [modelInstance, parameters]; //return modelInstance;
		}
	}
}

var train = function(trainingObj, data, iterations, gradientSamples) {
	var trainingResults = Optimize(trainingObj(data),
			{
				steps: iterations,
				estimator : { ELBO : { samples : gradientSamples }},
			});
	return sample(SampleGuide(trainingObj(), { params: trainingResults }));
}

var makeVector = function(arr) {
	return Tensor([arr.length,1], arr);
}

var nnparam = function (a, b) {
	return param({ dims: [a, b], mu: 0, sigma: 0.1});
};

var sampleMatrixGaussian = function (dims, mean, variance, guide_mean) {
	var length = dims[0] * dims[1]
	var g = sample(DiagCovGaussian({ mu: Vector(repeat(length, constF(mean))), sigma: Vector(repeat(length, constF(variance))) }),
	{ guide: DiagCovGaussian({ mu: T.reshape(guide_mean, [length, 1]), sigma: Vector(repeat(length, constF(0.001))) }) })
	return T.reshape(g, dims)
}

var sampleScalarGaussian = function (mean, variance, name) {
	return sample(Gaussian({ mu: mean, sigma: variance }),
	{ guide: Gaussian({ mu: param({ mu: mean, name: name }), sigma: 0.001 }) });
}

var nnGaussianParameterPrior = function (hiddenSize, inputSize) {
	var W0_var = nnparam(hiddenSize, inputSize)
	var W1_var = nnparam(1, hiddenSize)
	var b0_var = nnparam(hiddenSize, 1)
	var b1_var = nnparam(1, 1)

	var W0 = sampleMatrixGaussian([hiddenSize, inputSize], 0, 10, W0_var)
	var W1 = sampleMatrixGaussian([1, hiddenSize], 0, 10, W1_var)
	var b0 = sampleMatrixGaussian([hiddenSize, 1], 0, 10, b0_var)
	var b1 = sampleMatrixGaussian([1, 1], 0, 10, b1_var)

	return { W: [W0, W1], b: [b0, b1] };
}

