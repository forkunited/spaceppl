//var refs = ["p1", "p2", "p3"];
//var refMentions = map(strToMention, refs);
//display(makeUtterances([["spaceppl.space.near"], [_.first(refMentions)], _.rest(refMentions)]));
//display(randomSubset(refMentions, 2, true));
//display(makeUtterances([["spaceppl.space.near"], [2, true, refMentions]]));

//var args = parseArgs();
//display(args["out"]);

//var f = function() {
//    display(arguments[0] + " " + arguments[1]);
//}
//f("hi", "bye");

/* Put this back "learn.wppl", "world.wppl", "utterance.wppl", "rsa.wppl", "spatialRsa.wppl", "util.wppl", "experiment.wppl"*/

//spaceppl.rgame.getGameUtteranceActionPairs(spaceppl.rgame.readGame("output/4791-d"), spaceppl.rgame.senders.SPEAKER);

//spaceppl.feature.initFeatureUtteranceTokenAnnotation();

/*
var c = spaceppl.counter.init();
spaceppl.counter.increment(c, "hi");
spaceppl.counter.increment(c, "hi");
spaceppl.counter.increment(c, "hi");
spaceppl.counter.increment(c, "hi");
spaceppl.counter.increment(c, "bye");
spaceppl.counter.increment(c, "bye");
spaceppl.counter.increment(c, "by");
spaceppl.counter.increment(c, "t");

spaceppl.counter.removeLessThan(c, 2);
spaceppl.counter.increment(c, "new");
spaceppl.counter.increment(c, "dog");
spaceppl.counter.increment(c, "dog");
spaceppl.counter.increment(c, "dog");
spaceppl.counter.increment(c, "dog");

spaceppl.counter.increment(c, "zog");
spaceppl.counter.increment(c, "zog");
spaceppl.counter.increment(c, "zog");
spaceppl.counter.increment(c, "zog");

display(spaceppl.counter.getSortedCounts(c));
display(spaceppl.counter.getTop(c, 4));
display(spaceppl.counter.buildIndex(c));

var bi = spaceppl.bilookup.init(spaceppl.counter.buildIndex(c));
spaceppl.bilookup.save(bi, "output/testbi");
var lbi = spaceppl.bilookup.load("output/testbi"); //"output/testbi");
display(bi);
display("l");
display(lbi);
*/

// Run with
// webppl test.wppl --require webppl-nn --require . --gamesDir output/games/1 --iterations 2 --random-seed 2

var args = parseArgs();
var gamesDir = args["gamesDir"];

var utteranceFn = spaceppl.rgame.getPairedUtterancesFn(spaceppl.rgame.senders.SPEAKER);
var actionFn = spaceppl.rgame.getPairedActionsFn(spaceppl.rgame.senders.SPEAKER)

var inputFeatureTypes = [
    {
        name : "utok", type : spaceppl.feature.types.UTTERANCE_TOKEN_ANNOTATION_ENUMERABLE,
        parameters : { annotation : spaceppl.rgame.annotations.TOKEN, minCount : 5 }
    },
    {
        name : "boxX", type : spaceppl.feature.types.ACTION_DIMENSION_SCALAR,
        parameters : { prefix : "boxY" }
    },
    {
        name : "boxY", type : spaceppl.feature.types.ACTION_DIMENSION_SCALAR,
        parameters : { prefix : "boxY" }
    },
    {
        name : "boxW", type : spaceppl.feature.types.ACTION_DIMENSION_SCALAR,
        parameters : { prefix : "boxW" }
    },
    {
        name : "boxH", type : spaceppl.feature.types.ACTION_DIMENSION_SCALAR,
        parameters : { prefix : "boxH" }
    },
    {
        name : "boxC", type : spaceppl.feature.types.ACTION_DIMENSION_ENUMERABLE,
        parameters : { prefix : "boxC" }
    }
];

var inputVector = ["utok", "boxX", "boxY", "boxW", "boxH", "boxC"];
var inputf = spaceppl.feature.initFeatureSet("testInput", gamesDir, utteranceFn, actionFn, inputFeatureTypes, inputVector);
//spaceppl.feature.saveFeatureSet(f, "output/features/");
//var fLoad = spaceppl.feature.loadFeatureSet("output/features/");
//display(fLoad.features.utok.vocabulary);
var inputF = spaceppl.feature.computeFeatureSet(inputf, gamesDir, spaceppl.rgame.getGameUtteranceActionPairs);

var outputFeatureTypes = [
    {
        name : "mouse", type : spaceppl.feature.types.ACTION_DIMENSION_SCALAR,
        parameters : { prefix : "mouse" }
    }
];

var outputVector = ["mouse"];
var outputf = spaceppl.feature.initFeatureSet("testOutput", gamesDir, utteranceFn, actionFn, outputFeatureTypes, outputVector);
var outputF = spaceppl.feature.computeFeatureSet(outputf, gamesDir, spaceppl.rgame.getGameUtteranceActionPairs);

var D = makeDataFromFeatureMatrices(inputF, outputF, { inputSequence : true, outputSequence : false });

var D_split = splitDataOnKey(D, 0.9, "game");
var D_train = D_split[0];
var D_test = D_split[1];

var parameterPrior = function() {
    return {
        latentDimension: spaceppl.feature.getFeatureSetSize(inputf),
        outputDimension : spaceppl.feature.getFeatureSetSize(outputf),
        decoderType : DECODER_LINEAR,
    }
};

var batchSize = 100;
var iterations = args["iterations"]*1;
var gradientSamples = 1;

// Data [{ input, output}]

var makeModel = function(params) {
    var m = makeSequenceInputModel(params);
    return function(input) {
        //return Categorical({ ps : [1.0], vs : [m(input)] });
        return MultivariateGaussian({mu: m(input), cov : Matrix([[1.0,0.0],[0.0,1.0]])});
    }
};

var obj = makeTrainingObj(makeModel, parameterPrior, { inputSequence: true, outputSequence: false, batchSize: batchSize, modelObserves : false });
var results = train(obj, D_train, iterations, gradientSamples);

var trainedModel = results[0];

var Y_hat_train = map(function(d) { return trainedModel(d.input).params.mu }, D_train);
var Y_train = map(function(d) { return d.output; }, D_train);
var Y_hat_test = map(function(d) { return trainedModel(d.input).params.mu }, D_test);
var Y_test = map(function(d) { return d.output; }, D_test);

var trainMSE = spaceppl.evaluation.sampleMSE(Y_hat_train, Y_train);
var testMSE = spaceppl.evaluation.sampleMSE(Y_hat_test, Y_test);

display("iterations\ttrainMSE\ttestMSE");
display(iterations + "\t" + trainMSE + "\t" + testMSE);

/*
var M = MultivariateGaussian({ mu : Vector([1.0, 1.0]), cov : Matrix([[1.0,0.0],[0.0,1.0]])});
M.score(Vector([10.0,1.0]))
*/